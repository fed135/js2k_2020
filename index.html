<canvas width="800" height="480" style="width:800px;height:480px;background-color:#113;" id="a"></canvas>
<script>

// Canvas --------------------------------------------------------------------*/

var a = document.getElementById('a');
var c = a.getContext('2d');

// Config --------------------------------------------------------------------*/

var pixelSizeRatio = 4;
var maxAcceleration = 3;
var floor = 350;
var heroCenter = 180;
var charPad = 128 - 64;

// Utils ---------------------------------------------------------------------*/

var hashToMap = (hash) => {
  var zeroPad = num => '00000000'.slice(String(num).length);
  var h = '';
  for (var i = 0; i < hash.length; i++) {
    var num = (hash.charCodeAt(i) - charPad).toString(2);
    h += zeroPad(num);
    h += String(num);
  }
  return h.split('');
};

var collides = (a, b) => (
  Math.pow(
    Math.pow(a.x - b.x,2) + Math.pow(a.y - b.y,2)
    ,0.5
  ) < (pixelSizeRatio * 7)
);

var renderTileToBuffer = (entity) => {
  if (textureCache[entity.texture]) return entity.tile = textureCache[entity.texture];
  var [pattern, fillA, fillB] = entity.texture.split(',');
  var pixels = hashToMap(pattern);
  var tile = new OffscreenCanvas(8 * pixelSizeRatio, pattern.length * pixelSizeRatio)
  var tileContext = tile.getContext('2d');
  tileContext.fillStyle = '#' + (fillA || '00000000');
  tileContext.fillRect(0,0,8 * pixelSizeRatio, pattern.length * pixelSizeRatio);
  pixels.map((pixel, i) => {
    if (pixel == '1') tileContext.rect(i%8*pixelSizeRatio, ~~(i/8)*pixelSizeRatio, pixelSizeRatio, pixelSizeRatio);
  });
  tileContext.fillStyle = '#' + fillB;
  tileContext.fill();
  entity.tile = tile;
  textureCache[entity.texture] = tile;
};

// Game state ----------------------------------------------------------------*/

var hero = { life: 3, x: heroCenter, y: floor, accX: maxAcceleration, accY: 0, animFrame: 0 };
var camera = { xOffset: 0, lockedAt: 0 };
var shootLock = false;
// 0 = bg, 1 = walls, 2 = bullets, 3 = obstacles, 4 = enemies (hero)
var layers = [[],[],[],[],[]];

// Keyboard and mouse mapping ------------------------------------------------*/

var input = {};
var mouse = {
  x:0,
  y:0,
  down: false,
};

onmousemove = (evt) => {
  mouse.x = evt.offsetX;
  mouse.y = evt.offsetY;
};

onmouseup = () => {
  mouse.down = false;
};

onmousedown = () => {
  mouse.down = true;
};

onkeydown = (evt) => {
  input[evt.keyCode] = 1;
  // spacebar, jump
  if (evt.keyCode == 32 && !hero.inJump && !hero.inLanding) hero.jumpStart = true;
  if (evt.keyCode == 88) {
    // x, shoot
    if (shootLock) return;
    shootLock = true;
    setTimeout(() => shootLock = false, 500)
    layers[2].push({ x: hero.x+8*pixelSizeRatio, y: hero.y+2*pixelSizeRatio, accX: 5, accY: 0, texture: textures[2], createdAt: frameIndex, animFrame: 0 });
    renderTileToBuffer(layers[2][layers[2].length -1])
  }
};
onkeyup = (evt) => input[evt.keyCode] = 0;

// To sync animations
var frameIndex = 0;

/**
 * 0: monster, frame0
 * 1: floor tile, straight
 * 2: round bullet, frame 0
 * 3: round bullet, frame 1
 * 4: round bullet, frame 2
 * 5: hero layer 0, frame 0
 * 6: hero layer 0, frame 1
 * 7: hero layer 0, frame 2
 * 8: hero layer 1, frame 0
 * 9: hero layer 1, frame 1
 * 10: hero layer 1, frame 2
 * 11: hero layer 0, jump frame 0
 * 12: monster, dead
 */
var textures = [
    '¼ľïïĿĿ,,fff',
    'ĿÈÈÈĿbbb,,000',
    'XdÙÙdX,,fff',
    '|åÙÙå|,,fcc',
    '|ÑĝûÉ|,,fee',
    '^^^~|¸¼¿¿~\\||¶ĦĦ,,fb5',
    '@||||¼¿¿¾||||ttt,,fb5',
    '@^^~~¾¼¿¿¾||||\\\\,,fb5',
    '^XXpp°°³±p@@@@ĂĦ,,000',
    '@|p`` ³± `@@@@t~,,000',
    '@|p``°³¡ `@@@¼¼,,000',
    '~~~¾½¿¿¾|||~¾¸@@,,fb5',
    '¼ľ÷Ŀ,,666'
];
var textureCache = {};
var floorTexture = { texture: textures[1] };
renderTileToBuffer(floorTexture);
var floorPattern = c.createPattern(floorTexture.tile, 'repeat');

var draw = () => {
  frameIndex++;
  if (frameIndex % 300 == 0) frameIndex = 0; // Cycles every 5 seconds
  setTimeout(draw, 16);
  a.width = a.width; // Clears the canvas

  updatePlayer();

  updateDecor();
  updateBullets();
  updateEnemies();

  layers.map((layer)=>layer.map((entity) => {
    if (entity.tile) c.drawImage(entity.tile, entity.x, entity.y);
  }));
  //hero.tiles.map(tile => c.drawImage(tile, entity.x, entity.y));
  c.drawImage(hero.tile, hero.x, hero.y, 8*pixelSizeRatio, 16*pixelSizeRatio);
};

var updatePlayer = () => {
  // Update texture every 6 frames
  if (frameIndex % 6 == 0 || !hero.texture) {
    hero.texture = textures[(++hero.animFrame%3)+5];
    renderTileToBuffer(hero);
  }

  // Update position
  hero.y += hero.accY;
  camera.lockedAt += Math.max(hero.accX, 0);
  camera.xOffset += hero.accX;
  /*hero.x = camera.xOffset - camera.lockedAt + heroCenter;
  if (hero.x < 0) {
    hero.x = 0;
    hero.accX += 0.1;
  }*/

  if (hero.jumpStart && hero.texture != textures[11]) {
    hero.accX = 2;
    hero.texture = textures[11];
    renderTileToBuffer(hero);
    hero.accY = -20;
    hero.inJump = true;
    hero.jumpStart = false;
  }
  else if (hero.inJump) {
    hero.accY *= 0.9;
    if (hero.accY >= -1) {
      hero.inJump = false;
      hero.inLanding = true;
      hero.accY = 3;
    }
  }
  else {
    if (hero.inLanding) {
      hero.accY *= 1.1;
      if (hero.y >= floor) {
        hero.y = floor;
        hero.accX = maxAcceleration;
        hero.accY = 0;
        hero.inLanding = false;
      }
    }
    /*
    if (input[37] == '1') {
      if (hero.accX > 0) {
        hero.accX = 0;
        hero.scaleX = -1;
      }
      hero.accX = Math.max(hero.accX - 0.1, -maxAcceleration);
    }
    if (input[39] == '1') {
      if (hero.accX < 0) {
        hero.accX = 0;
        hero.scaleX = 1;
      }
      hero.accX = Math.min(hero.accX + 0.1, maxAcceleration);
    }
    */
  }
};

var updateDecor = () => {
  c.fillStyle='#343';
  c.fillRect(0, floor+16*pixelSizeRatio, 800, 480-floor);
  c.fillStyle=floorPattern;
  c.save();
  c.translate(-(camera.xOffset % (8*pixelSizeRatio)), 0);
  c.fillRect(0, floor+16*pixelSizeRatio, 800, 480-floor);
  c.restore();
};

var updateBullets = () => {
  layers[2].map((bullet, i, l) => {
    // Update texture every 5 frames
    if ((frameIndex - bullet.createdAt) % 5 == 0) {
        bullet.texture = textures[(++bullet.animFrame%3)+2];
        renderTileToBuffer(bullet);
    }
    // Update location
    bullet.x += bullet.accX;
    bullet.y += bullet.accY;

    // Check collisions
    layers[4].map((enemy) => {
      if (collides(bullet, enemy)) {
        enemy.killed = true;
        l.splice(i,1);
      }
    });
  });
};

var updateEnemies = () => {
  if (~~camera.offsetX % 100 == ~~(Math.random()*100)) {
    // spawn monster
    layers[4].push({x:800, y: Math.random() * (floor - 64) + 100, texture: textures[0] })
    renderTileToBuffer(layers[4][layers[4].length -1])
  }

  layers[4].map((enemy) => {
    // Update texture if killed
    if (enemy.killed) {
        enemy.texture = textures[12];
        renderTileToBuffer(enemy);
        enemy.y+=4;
        return;
    }

    enemy.x -= 3

    // If hero in sight and timing of 1s done, switch to shooting stance

    // If in shooting stance for 1s, fire bullet towards hero

    // Check collision with hero
    if (collides(hero, enemy)) {
      alert('game over')
    } // Get damage
  });
};

draw();

</script>
